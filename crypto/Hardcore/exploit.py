import os; os.environ["PWNLIB_NOTERM"] = "1" # for tqdm this time
from pwn import *
import tqdm
from json import loads, dumps
from Crypto.Cipher import AES
from Crypto.PublicKey import RSA
from Crypto.Util.Padding import unpad
import hashlib
from sage.all import GF, discrete_log, crt, sqrt, ZZ


if args.LOCAL:
    io = process(["./target/release/hardcore"])
else:
    io = remote(args.HOST, args.PORT)

io.recvuntil(b"N = ")
n = int(io.recvline())
g = int(io.recvline().split(b" = ")[1])
pub = int(io.recvline().split(b" = ")[1])
alice = int(io.recvline().split(b" = ")[1])
nbits = int(io.recvline().split(b" = ")[1])
FLAG = bytes.fromhex(io.recvline().split(b" = ")[1].strip().decode())

index = nbits - 123
d = 0

def has(P, fail=True):
    io.sendline(str(P).encode())
    res = int(io.recvline())
    if fail:
        assert res in [0,1]
    return {1: True, 0: False, -1: None}[res]

def setbit(P, i):
    # assert not hasbit(P, i)
    return (P * pow(g, 1 << i, n)) % n

def clearbit(P, i):
    return (P * pow(g, -(1 << i), n)) % n

def set(i):
    global d
    d |= (1 << i)

def right_bits(P, i):
    if has(P):
        set(i)
        P = clearbit(P, i)
    for j in tqdm.tqdm(range(i - 1, -1, -1)):
        if has(setbit(P, j)):
            set(j)
        else:
            P = setbit(P, j)
    return P

def left_bits(P, idx):
    for i in tqdm.trange(idx + 1, nbits):
        P = setbit(clearbit(P, 0), idx) # Clear LSB -> make square; make the current bit part of the 1 sled before shifting
        for ss in [crt([ZZ(x), ZZ(y)], [p, q]) for x in sqrt(GF(p)(P), all=True) for y in sqrt(GF(q)(P), all=True)]:
            candidate_bit = has(ss, fail=False)
            if candidate_bit is None: continue
            if candidate_bit:
                Q = clearbit(ss, idx)
            else:
                Q = ss
            if has(setbit(Q, 0)): # see if it flows all the way over the 1s
                P = Q
                if candidate_bit:
                    set(i)
                break
        else:
            raise RuntimeError("Could not find a good square root")


# TODO: Mind wrap-around
# if right_bits wraps (and introduces error), MSB = 1, then repeat with MSB set to 0

def dec(d):
    shared = pow(alice, d, n)
    key = hashlib.sha256(str(shared).encode()).digest()
    cipher = AES.new(key, AES.MODE_CTR, nonce=bytes(12))
    try:
        return cipher.decrypt(FLAG).decode()
    except Exception as e:
        return str(e)

right_bits(pow(g, n, n), index)
order_multiple = n - d
assert pow(g, order_multiple, n) == 1

p = RSA.construct((n, 0x10001, pow(0x10001, -1, order_multiple))).p
assert n % p == 0 and n != p
q = n // p

print("Cheese part 2: ", end="")
d = int(crt([discrete_log(GF(p)(pub), GF(p)(g)), discrete_log(GF(q)(pub), GF(q)(g))], [p - 1, q - 1]))
print(dec(d))

d = 0
P = right_bits(pub, index)
left_bits(P, index)
print(dec(d))
